# Ethereum vs Fabric

## 架构定位

- Ethereum整体上是一个紧耦合的架构, 每个全节点平等且需要负责共识, 出块, 背书, 验证, 记账, 同步, 合约运行, 交易签名等全部功能, 架构简单, 部署方便, 功能模块完整, 集成度高, 不可插拔, 扩展性较差. 除全节点外, Ethereum还支持轻节点, 轻节点依赖MPT(默克尔-帕特里夏树)和Blood Filter结构实现简单支付验证(SPV), 保证节点无需同步整个区块链就能进行交易, 满足公有链需求. Ethereum是一个定位公有链的系统(https://ethstats.net/), 他虽然也支持私有链和联盟链, 但他本身的一些特性和存在的问题导致其并不适合于私有链和联盟链的一些需求, 因此Ethereum比较适合B2C的场景.
- Fabric整体上是一个松耦合的架构, 背书记账验证节点, 共识出块节点分离, 成员管理和安全认证节点相互分离, 智能合约(链码)运行于Docker环境中, 架构复杂, 部署过程繁杂, 功能模块有待完善, 集成度低, 模块可插拔, 扩展性好. Fabric是直接定位联盟链的, 并不支持公有链, 也不支持轻节点(无SPV), 因此Fabric比较适合B2B的场景.

## 共识机制

- Ethereum当前的共识机制与比特币类似, 属于POW(工作量证明)机制, 即依赖节点挖矿实现共识, 生成区块. 挖矿进行无意义计算, 消耗资源, 出块时间可控性稍差, 交易确认效率低, 容易造成网络拥堵. 且由于Ethereum是面向公有链的, 全球共用一条公链, 交易量巨大, 区块增长速度快, 拥堵问题更加严重(目前公链每秒只能处理15笔交易). 另外其共识机制受公有链特性约束, 采取的是最终一致性而非强一致性, 因此会有区块链分叉和51%攻击的风险(分叉问题使用基于幽灵协议的叔块机制处理, 51%攻击问题依赖公有链本身的广度避免). Ethereum计划在第四个阶段(目前处于第二阶段, 这需要几年时间)将共识机制更改为Casper, 即POW与POS(权益证明)混合机制, 不再需要挖矿,而是以对赌的方式选出出块节点. 网络拥堵和TPS(每秒交易数量)问题也计划在第四阶段依靠分片技术进行解决, 但一切还是未知数.
- Fabric因为是面向联盟链的, 节点数量有限, 因此其共识机制是强一致性的, 不存在区块链分叉问题. Fabric出块时间可控, TPS高, 较难出现拥堵问题, 能够满足高吞吐量的商业需求. Fabirc的强一致性共识目前是依赖kafka和zookeeper集群实现, kafka集群是一个基于发布订阅的消息队列系统, zookeeper是一个分布式协调系统, peer节点, orderer节点, kafka集群通过与zookeeper集群的交互实现强一致性共识, 保证各记账节点(peer节点)区块的一致性. zookeeper系统是通过选举leader节点来进行协调记账的, 因此Fabric目前的共识机制类似于DPOS. 未来Fabric将支持拜占庭容错算法(PBFT)及其变种, 这同样是一种强一致性算法, 但这种算法要求共识节点(orderer节点)必须2/3是正常的.

## 账号钱包

- Ethereum内置账号功能和代币(Ether), 能够直接生成账号并进行账号之间的代币交易, Ethereum官方还提供Mist钱包模块支持对账号的高级管理(类似银行), 另外还有很多第三方钱包提供账号管理功能. Ethereum的代币不仅用于交易流通, 也用于支付进行智能合约部署和处理交易的手续费(gas), 手续费可以防止恶意代码攻击.
- Fabric没有提供用于交易的账号和代币, 更不存在钱包的概念, 交易处理也不需要手续费. 如有账号代币和钱包需求, 需要自己实现.

## 应用商店

- Ethereum依赖其公有链和智能合约, 已经形成了一个活跃的去中心化的生态环境, 出现了众多的去中心化应用(Dapp)商店.
- Fabric因其联盟链的定位, 更偏向于商业场景, 无法形成面向世界的去中心化生态系统.

## 智能合约

- Ethereum的智能合约是运行在EVM虚拟机环境下的字节码程序, 支持使用Solidity(主流)等高级编程语言进行编写, Ethereum的智能合约类似面向对象编程语言中的类, 合约可以继承, 可以相互调用. Ethereum的合约是作为交易直接写入区块链中的, 因为交易需要消耗gas, 而每个区块所能消耗的gas数量是有上限的(此上限值是变化的), 因此交易的大小有限制, 合约大小自然一样受限(截止2018.05.22时gas限制大约800w, 对应交易大小上限大约在2MB). 通过合约的JSON interface和合约地址被API调用. 合约可以销毁, 但不可以更新. 编写合约的主流语言Solidity目前还处于不断完善的阶段, 功能支持有限, 库函数也少, 语言本身受gas设定所限, 合约大小有上限, 合约运行也会消耗gas, 因此Ethereum的合约不能处理复杂业务和大量数据.
- Fabric的智能合约是运行在Docker容器里的实现了特定API接口的代码, 称为链码, 链码支持使用Go(主流), Node 和Java等高级编程语言编写, 仅仅需要实现链码接口和shim接口用于链码调用和区块链账本访问. Fabric的链码之间也可以相互调用(以交易的形式), 链码是直接部署在各peer节点上的(未部署链码的节点就不能进行交易背书, 只能用于交易验证和记账). Fabric链码可以更新也可以销毁. 链码没有大小限制, 执行过程也没有代币消耗, 支持语言本身的完整特性, 功能强大, 库函数丰富, 能够处理复杂的业务和大量的数据.

## 账本子链

- Ethereum的分布式账本是完全存在于区块链上的, 整个区块链都存储于leveldb数据库中, 每一个区块均包含三颗默克尔-帕特里夏树, 分别为交易树, 状态树, 收据树. 交易树包含自上一个区块以来的所有交易, 状态树存储整个区块链的最新状态(与比特币不同, 比特币的最新状态的获取需要回溯各个区块计算最终状态), 收据树记录每笔交易产生的影响(凭条). Ethereum不支持子链, 链与链之间无法互通.
- Fabric的分布式账本是存储于二进制文件中的, 区块中交易是以读写集的形式计入的, 在链码中是以key-value的形式存入区块链的. 区块链的最新状态则保存在链外的单独的状态数据库中(目前支持leveldb和couchdb, 前者是主流). 目前状态数据库存在被人为修改的风险, 区块链无法对状态数据库的篡改作出反应. Fabric可以通过channel机制实现对子链的支持. 子链之间, 子链与主链之间无法互通.

## 权限监管

- Ethereum的节点加入和合约调用均没有权限限制, 区块链上进行交易活动的账号均是匿名地址(公钥的后20个字节), 因此也无法进行监管.
- Fabric依靠CA认证模块提供节点准入机制, 链码策略和背书策略限制的各节点的链码部署和交易背书权限, 通道机制保证节点只能访问本节点所在通道的区块链数据. 区块链上的用户均在CA模块上进行认证, 组织关系清晰, 便于监管.

## 开发环境

- Ethereum集成度高, 功能相对完善, 官方文档比较成熟, 内容完善详实, 可操作性强, 第三方资料丰富, Ethereum支持commandline(IPC), 应用程序API和REST API三种交互方式, 应用程序API支持的语言比较全面, 有比较友好的Dapp开发框架(truffle + ganache + Mist), 有专门的合约开发和测试IDE(remix). Ethereum的智能合约语言Solidity还在不断完善过程中, 功能较弱, 且新旧版本语法之间存在兼容问题. Ethereum官方提供的API也在不断完善过程中, 1.0版API尚处在Beta阶段, 且与目前广泛应用的0.x版存在较大的兼容性问题. 总体而言Ethereum的开发环境比较良好, 二次开发较少, 开发周期会比较短.
- Fabric集成度低, 功能尚需完善, 更像一个框架, 需要在其基础上进行二次开发(如账号, 代币和钱包功能, 区块链状态监控等), 官方文档不够详细, 文档完成度较低, 可操作性低, 第三方资料相对较少. Fabric支持CLI, 应用程序API和REST API三种交互方式, 应用程序API目前支持Node, Java和Go, 但只有Node的支持较好, 没有成型的开发框架. Fabric的智能合约语言强大, 链码开发比较简单方便, 链码测试则相对麻烦. 总体而言Fabric的开发环境稍差, 二次开发较多, 开发周期会比较长.
